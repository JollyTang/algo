# 自我介绍
面试官你好，我是jollytang，是中国科学技术大学软件学院研二的学生。
技术栈主要是java，python，go相关的。
之前在腾讯ieg增值服务部实习，做的主要是监控系统，可观测相关的工作。
包括监控管理端，数据处理引擎，监控告警引擎等服务。
现在在美团履约平台技术部实习，主要做工作流，数据集，数据标注，任务巡检评测等工作。
平常生活中对AI有些兴趣，所以也做了一个Agent项目进行尝试。
日常工作中也在慢慢把AI加入进来，可在AI帮助下进行全栈开发。
如果用几个词来描述我之前的工作的话，那就是监控可观测，数据闭环，Agent，AI全栈开发。
以上就是一个简单的自我介绍，谢谢。

准备几个hook
由AiCoding -> 数据集血缘重放机制 -> 执行计划DAG构建 | 设计模式 | 大数据框架中数据集的处理
由设计模式 -> 腾讯硬编码策略优化，责任链和策略 | 项目中监控的装饰器模式 
# 数据集的血缘重放机制
可以引出下列知识点
## spark,flink在执行前构建DAG执行图
Spark：RDD 对象天然就是节点，依赖关系天然就是边；Action 触发时由 DAGScheduler 一次性切开 Shuffle 点得到 Stage DAG。
Flink：每写一行代码先产出 Transformation，再经过 合并-展开-并行化 三次加工，才落到可执行的 ExecutionGraph DAG。
## sql执行计划图
sql在执行的过程中，也会构建类似的DAG执行图，
执行顺序总结
FROM：确定数据来源。
WHERE：对数据源进行过滤。
GROUP BY：对过滤后的数据进行分组。
HAVING：对分组后的数据进行过滤。
SELECT：选择需要的列。
ORDER BY：对最终结果进行排序。

### sql的执行可以映射到spark场景，也就变成了hive on spark
查询的各种操作变成了spark的算子。

## linux的管道操作
不是dag，但是形成了执行链，把上一个shell命令的输出当成下一个shell命令的输入。

## git的commit提交链。

## 代码中如何来做呢？
命令模式，策略模式，装饰器模式，组合模式
命令模式和策略模式都是一个抽象类，抽象方法，然后具体的命令或者策略继承这个抽象方法，实现抽象类即可。
装饰器模式像套娃一样，一层层包住原对象，每包一层就给它加一个新能力，这就是装饰器模式。
组合模式就是把“单个对象”和“由对象组成的树形容器”当成同一种东西来递归使用，这就是组合模式。

# 熟悉设计模式

## 项目中使用的策略模式 
### 数据集
数据集的血缘关系构建，重放机制使用了类似的方式。
### 数据兼容 责任链+策略模式
在业务场景中，原来硬编码了三种不同的数据处理方式，第一种是过滤类，第二种是修改类，第三种是其他类型。通过把他们抽象成策略来进行处理，第一种就是过滤策略，第二种就是修改策略，第三种是任意类型的策略，通过重写抽象方法可以做到想怎么改怎么改。在通过责任链模式把之前长达快一百多行的if判断给修改成不过几行的责任链调用，实现对原来代码的重构，并且相对之前来说，不论是扩展性还是可读性都提升不少。
总结：如果你需要“按顺序尝试多种处理逻辑，又想随时替换其中任意一环的算法”，把责任链当骨架、策略当插件就是业界最省心的做法。
## 了解的其他设计模式
### 迭代器模式
在很多地方都有使用到，熟悉的比如有在编程语言中迭代对象。消息队列，数据库。
本质上就是按需要吐出数据，而不是一次把数据都搬进内存。
如何实现？把对数据的一些操作封装在hasNext和next中，让使用者通过这个来判断是否有数据和获取下个数据，而忽略数据有多大和存在什么介质。
### 单例模式
让全局只有一个对象，比如配置，连接池。
枚举最稳；懒汉最灵活；饿汉最简单；双重锁最危险（记得 volatile）。
```java
public class President {
    private static volatile President instance;   // 少了 volatile 线程会拿到半对象
    private President() {}
    public static President getInstance() {
        if (instance == null) {
            synchronized (President.class) {
                if (instance == null) instance = new President();
            }
        }
        return instance;
    }
}
```
### visitor模式
Visitor 让你在不改原有类的前提下，给一批对象动态增加新功能。
```python
from abc import ABC, abstractmethod

# 1. 元素基类：乘客
class Passenger(ABC):
    @abstractmethod
    def accept(self, visitor): pass

# 2. 具体乘客：普通 & 老人
class OrdinaryPassenger(Passenger):
    def accept(self, visitor):
        visitor.visit_ordinary(self)

class ElderPassenger(Passenger):
    def accept(self, visitor):
        visitor.visit_elder(self)

# 3. 访问者基类：安检员
class SecurityVisitor(ABC):
    @abstractmethod
    def visit_ordinary(self, p): pass
    @abstractmethod
    def visit_elder(self, p): pass

# 4. 具体安检员：身体检查 & 行李检查
class BodyCheckVisitor(SecurityVisitor):
    def visit_ordinary(self, p):
        print("👮 对普通乘客搜身")
    def visit_elder(self, p):
        print("👮 对老人乘客轻拍搜身")

class LuggageCheckVisitor(SecurityVisitor):
    def visit_ordinary(self, p):
        print("🧳 检查普通乘客行李")
    def visit_elder(self, p):
        print("🧳 检查老人乘客行李")

# 5. 客户端：地铁入口
queue = [OrdinaryPassenger(), ElderPassenger()]

# 今天先执行两种安检
for p in queue:
    p.accept(BodyCheckVisitor())
    p.accept(LuggageCheckVisitor())

# 明天想加“金属探测”？新建一个 MetalDetectorVisitor 即可
```

### 装饰器模式
```python
from abc import ABC, abstractmethod

# 1. 被装饰者接口
class Passenger(ABC):
    @abstractmethod
    def pass_gate(self): pass

# 2. 具体乘客
class OrdinaryPassenger(Passenger):
    def pass_gate(self):
        print("普通乘客准备进站")

class ElderPassenger(Passenger):
    def pass_gate(self):
        print("老人乘客准备进站")

# 3. 装饰器基类
class SecurityDecorator(Passenger): # 这里要继承抽象类
    def __init__(self, passenger: Passenger):
        self._passenger = passenger

    def pass_gate(self):
        self._passenger.pass_gate()

# 4. 具体装备（装饰器）
class BodyCheckDecorator(SecurityDecorator):
    def pass_gate(self):
        super().pass_gate()
        print("👮 对乘客搜身")

class LuggageScanDecorator(SecurityDecorator):
    def pass_gate(self):
        super().pass_gate()
        print("🧳 行李扫描")

class MetalDetectorDecorator(SecurityDecorator):
    def pass_gate(self):
        super().pass_gate()
        print("🔍 金属探测")

# 5. 客户端：给乘客“穿装备”
p = OrdinaryPassenger()

# 想穿几件穿几件，顺序随意
dressed = MetalDetectorDecorator(
            LuggageScanDecorator(
              BodyCheckDecorator(p)))

dressed.pass_gate()
```